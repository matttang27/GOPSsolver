from __future__ import annotations

import unittest

import numpy as np

from tests import test_support

from exploitability import (
    ExploitabilityEvaluator,
    evaluate_average_exploitability,
    guarantee_values,
    normalize_distribution,
)
from common import remove_card


class TestExploitabilityUtils(unittest.TestCase):
    def test_normalize_distribution_filters_and_renormalizes(self) -> None:
        actions = [1, 2, 3]
        weights = np.array([-1.0, 0.0, 4.0], dtype=np.float64)
        out_actions, out_probs = normalize_distribution(actions, weights, eps=1e-12)
        self.assertEqual(out_actions, [3])
        np.testing.assert_allclose(out_probs, np.array([1.0], dtype=np.float64), rtol=0.0, atol=0.0)

    def test_normalize_distribution_fallback_when_all_below_eps(self) -> None:
        actions = [7, 8]
        weights = np.array([1e-13, 2e-13], dtype=np.float64)
        out_actions, out_probs = normalize_distribution(actions, weights, eps=1e-12)
        self.assertEqual(out_actions, [8])
        np.testing.assert_allclose(out_probs, np.array([1.0], dtype=np.float64), rtol=0.0, atol=0.0)

    def test_guarantee_values_sequence(self) -> None:
        # prize mask for cards [1, 3]
        values = guarantee_values(test_support.mask([1, 3]))
        self.assertEqual(values, (-4, 2, 4))

    def test_shift_with_win_saturation(self) -> None:
        ev = ExploitabilityEvaluator(
            policy="random",
            eval_objective="win",
            policy_eps=1e-12,
            strategy_cache=None,
            n=2,
        )
        values = np.array([-1.0, -0.5, 0.0, 0.5, 1.0], dtype=np.float64)

        out_plus = ev._shift_with_win_saturation(values, 2)
        np.testing.assert_allclose(
            out_plus,
            np.array([0.0, 0.5, 1.0, 1.0, 1.0], dtype=np.float64),
            rtol=0.0,
            atol=0.0,
        )

        out_minus = ev._shift_with_win_saturation(values, -2)
        np.testing.assert_allclose(
            out_minus,
            np.array([-1.0, -1.0, -1.0, -0.5, 0.0], dtype=np.float64),
            rtol=0.0,
            atol=0.0,
        )

    def test_random_policy_n1_has_zero_average_exploitability(self) -> None:
        evaluator = ExploitabilityEvaluator(
            policy="random",
            eval_objective="win",
            policy_eps=1e-12,
            strategy_cache=None,
            n=1,
        )
        result = evaluate_average_exploitability(n=1, evaluator=evaluator)
        self.assertAlmostEqual(result["avg_value_a_under_best_response"], 0.0, places=12)
        self.assertAlmostEqual(result["avg_max_exploitability"], 0.0, places=12)

    def test_exploit_side_guarantee_uses_current_prize(self) -> None:
        evaluator = ExploitabilityEvaluator(
            policy="random",
            eval_objective="win",
            policy_eps=1e-12,
            strategy_cache=None,
            n=4,
            use_exploit_guarantee=True,
        )
        a = test_support.mask([1, 2])
        b = test_support.mask([3, 4])
        self.assertTrue(evaluator._exploit_side_guaranteed_win(a, b, 0, 0, 4))

        evaluator_no_guarantee = ExploitabilityEvaluator(
            policy="random",
            eval_objective="win",
            policy_eps=1e-12,
            strategy_cache=None,
            n=4,
            use_exploit_guarantee=False,
        )
        self.assertFalse(evaluator_no_guarantee._exploit_side_guaranteed_win(a, b, 0, 0, 4))

    def test_random_policy_n2_expected_value_is_negative_for_a(self) -> None:
        evaluator = ExploitabilityEvaluator(
            policy="random",
            eval_objective="win",
            policy_eps=1e-12,
            strategy_cache=None,
            n=2,
        )
        full = (1 << 2) - 1
        cur_p = 1
        remaining = remove_card(full, cur_p)
        value = evaluator.br_value(full, full, remaining, 0, cur_p)
        self.assertLess(value, 0.0)


if __name__ == "__main__":
    unittest.main()
